# -*- Encoding: utf-8 -*-
#+STARTUP: hidestars hideall
#+OPTIONS: ^:{}
#+OPTIONS: TOC:nil

* Introduction
** General
  This is my emacs configuration file, to which I constantly add stuff shamelessly stolen from others.
  I try to attribute wherever I take a big (or significant) chunk of stuff.
** Major Thanks and attributions
*** Much of my stuff was takenfrom (and taught to me by) [[https://www.linkedin.com/in/dovgrobgeld][Dov Grobgeld]] ([[https://github.com/dov][github repository here]])
*** A lot of additional stuff (including how to organize the init file as an org mode) I learned from [[http://cestlaz.github.io/stories/emacs/][Mark Zamansky's excellent blog on emacs]]

** To use this file, add lines similar to the following to ~/.emacs:
                                        ;This is done to safely ignore local-variables warnings
(setq enable-local-variables :safe)

                                        ;Setting basic location and variables - override those if needed
(defvar emacs-git
  "/home/simon/github/SimonEnv/Emacs/"
  "The location of my Emacs environment settings")

(defvar default-work-notes-file
  "/home/simon/github/Notes/WorkNoteBook.org"
  "The location of my Work Notebook (somewhere on the work server?)")

(defvar default-personal-notes-file
  "/home/simon/Notebook/NoteBook.org"
  "The location of my personal notebook (mounted from EncFS)")

(defvar default-init-file 
  (concat emacs-git "/SimonNewInit.org") 
  "My Init File")

(defvar my-emacs-monitors-num 1
  "The number of monitors to take into account when calculating the Emacs window size (2/3 of the
  available width)")

                                        ;emacs persistance directory
(if (not (boundp 'emacs-persistance-dir))
    (setq emacs-persistance-dir "/home/simon/.emacs.d")
)

                                        ;Loading the rest of the configuration from my environment
;;The old way
;(load default-init-file)

;;The new (org-mode) way
(org-babel-load-file default-init-file)

* Setting up the basics
** Default files and directories
  #+BEGIN_SRC emacs-lisp
    (if (not (boundp 'default-init-file))
        (defvar default-init-file 
          (concat emacs-git "SimonNewInit.org") 
          "My Init File")
      )

    (defvar default-init-filename
      (file-name-nondirectory default-init-file)
      "Name of the default init file"
      )

    (if (boundp 'default-work-notes-file)
        (defvar work-notebook-filename
          (file-name-nondirectory default-work-notes-file)
          "Name of the default Work Notebook")
      )

    (if (boundp 'default-personal-notes-file)
        (defvar personal-notebook-filename
          (file-name-nondirectory default-personal-notes-file)
          "Name of the default Personal Notebook")
      )

  #+END_SRC
** Number of monitors attached
   #+BEGIN_SRC emacs-lisp
     (if (not (boundp 'my-emacs-monitors-num))
         (defvar my-emacs-monitors-num 1
               "The number of monitors to take into account when
                calculating the Emacs window size (2/3 of the available
                width)") )
   #+END_SRC
** Windows vs Linux Settings
   #+BEGIN_SRC emacs-lisp
     (if (string-match "mingw" system-configuration)
                                             ;On Windows
         (progn
           (if (not (boundp 'emacs-git))
               (defvar emacs-git "D:/Simon/github/SimonEnv/Emacs/"
                 "/home/simon/github/SimonEnv/Emacs/"
                 "The location of my Emacs environment settings"))
           (if (not (boundp 'emacs-persistance-dir))
               (setq emacs-persistance-dir "C:/Documents and Settings/simon/Application Data/.emacs.d"))

           ;; don't use Hebrew locale!
           (setq system-time-locale "C")

           ;; Load windows utilities - those include send buffer to VS by Dov.
           ;; TODO: Check this out
                                             ;      (load (concat emacs-git "win-utils.el")))

           ;; Various settings to use utf-8 (From Dov, I don't understand them all)
           (setq utf-translate-cjk-mode nil) ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
           (set-language-environment 'utf-8)
           (set-keyboard-coding-system 'utf-8-mac) ; For old Carbon emacs on OS X only
           (setq locale-coding-system 'utf-8)
           (set-default-coding-systems 'utf-8)
           (set-terminal-coding-system 'utf-8)
           (prefer-coding-system 'utf-8)

           ;; Add M-F4 to closing emacs, as apparently it is not caught by the windows manager
           (global-set-key (kbd "M-<f4>") 'save-buffers-kill-terminal) ; Close EMACS (Microsoft style)

           ;; Chrome command for windows (assumes C:\Program Files (x86)\Google\Chrome\Application is in path)
           (if (not (boundp 'my-chrome-command))
               (defvar my-chrome-command "chrome" "The command to run Google-Chrome"))

           )
                                             ;On Linux
       (progn
                                        
         (if (not (boundp 'emacs-git))
             (defvar emacs-git "/home/simon/github/SimonEnv/Emacs/"
               "/home/simon/github/SimonEnv/Emacs/"
               "The location of my Emacs environment settings"))
    
         (if (not (boundp 'emacs-persistance-dir))
             (setq emacs-persistance-dir "/home/simon/.emacs.d"))

         ;; Use Miriam mono font for Hebrew (???)
         (set-fontset-font "fontset-default" '(#x5d0 . #x5ff) "Miriam Mono CLM:bold")
         (set-face-font 'default "fontset-default")
         (setq load-path (append (list
                                  "/usr/local/share/emacs/site-lisp"
                                  ) load-path))

         ;; Chrome command for linux
         (if (not (boundp 'my-chrome-command))
             (defvar my-chrome-command "google-chrome" "The command to run Google-Chrome"))
         (setq browse-url-generic-program "google-chrome")
         ) 
       )
   #+END_SRC

** Fonts
   I use the "InconsolataDov" font size 11 for code. This font (located in the repository) must be installed
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font .   "InconsolataDov 11"))
  (set-face-attribute 'default t :font  "InconsolataDov 11" )

  (set-face-attribute 'default nil :font  "InconsolataDov 11" )
  (set-frame-font   "InconsolataDov 11" nil t)

  (setq my-default-family "InconsolataDov 11")
  (setq my-default-font "InconsolataDov 11")
#+END_SRC

* GUI and Visuals
** Misc small things
   #+BEGIN_SRC emacs-lisp
                                                  ;Toolbars
          (setq menu-bar-mode 't)
          (tool-bar-mode 0)

                                                  ;(non) Blinking Cursor
          (blink-cursor-mode 0)

                                                  ;Show row and column in a mini-mode
          (column-number-mode t)
          (line-number-mode t)

                                                  ;Skip the annoying startup screen
          (setq inhibit-startup-screen t)

                                                  ;TODO: Not sure what that is - inherited from Dov
     ;     `(safe-local-variable-values (quote ((Encoding . utf-8))))

                                                  ;Mark correspondind parentheses
          (show-paren-mode t)

                                                  ;Overwrite Selection
          (delete-selection-mode t)

                                                  ;Reload changed files
          (global-auto-revert-mode t)

                                                  ;Don't add newline at end of file
          (setq mode-require-final-newline nil)

   #+END_SRC
** Invert colors for my emacs editor
   #+BEGIN_SRC emacs-lisp
                                             ; Invert Colors only on the first time emacs is run
     (if (not (boundp 'my-do-invert-color))(defvar my-do-invert-color t "Is color inversion is required (only once)"))

     (if my-do-invert-color
         (progn 
           (invert-face 'default)
           (custom-set-faces `(cursor ((t (:background "white")))))
           (setq my-do-invert-color nil)
           )
       )
   #+END_SRC
** Emacs main window size
   #+BEGIN_SRC emacs-lisp
                                             ;Emacs window size
     ;The following was taken from Scott McPeak's "scott.emacs.el". Thank you Scott
     ; ---------------- frame move/resize (i.e. X window) -----------------------
     (defun frame-move-resize
         (width-fraction height-fraction      ; fractions of screen width, height
                         horiz-pos vert-pos)                 ; pels from left, top (neg: right, bot)
       "Move and resize the frame so its width and height are the given
       fractional amounts of the screen width and height, and it is positioned
       from the left (negative: right) and top (negative: bottom) edges by
       the specified number of pixels."
       (if window-system
           (let* ((char-width (frame-char-width))          ; character width in pels
                  (char-height (frame-char-height))        ; char height
                  (disp-width (x-display-pixel-width))     ; screen width in pels
                  (disp-height (x-display-pixel-height))   ; screen height
                  (frame (selected-frame))                 ; frame to act upon
                  (new-columns
                   (round (/ (* disp-width width-fraction) char-width)))
                  (new-lines
                   (round (/ (* disp-height height-fraction) char-height)))
                  )
             (set-frame-size frame new-columns new-lines)  ; do actual resize
             (sleep-for 0.5)                               ; see below
             (set-frame-position frame horiz-pos vert-pos) ; and move (after resize)

                                             ; There is a bug where sometimes, inexplicably, the window appears
                                             ; shifted about halfway off the right edge of the screen.  I have no
                                             ; idea which software the bug is in (emacs, X server, KDE, ...).
                                             ; It can be reliably reproduced by running, in sequence:
                                             ;   `frame-occupy-normal-position'
                                             ;   `frame-occupy-normal-position'
                                             ;   `frame-occupy-right-half-screen'
                                             ;   `frame-occupy-normal-position'        ; here it will be bad
                                             ;   `frame-occupy-normal-position'        ; one more gets it back ok
                                             ;
                                             ; Update:  On a hunch it was (at least partially) a race condition
                                             ; I've inserted a 0.1 second delay between resize and move, and this
                                             ; has cured the problem (at least when running on my system with emacs
                                             ; running on the same machine as the X server).
                                             ;
                                             ; Faster machine, longer delay (?): 0.2 secs works now..
                                             ; Then again, no delay at all also works!  cool.
                                             ; no it doesn't.. but the delay doesn't help..
                                             ; nothing works except doing it twice...
             )
         ))  

     (setq my-height-fraction 1) ;use the entire screen height
     (setq left-two-thirds-screen-pos (list 0.6 my-height-fraction 0 0))    ;last two: 0 from left, 0 from top
     (defun frame-occupy-left-two-thirds-screen ()
       "Move and resize the frame so it occupies the left ⅔ of the screen."
       (interactive)
       (apply 'frame-move-resize left-two-thirds-screen-pos))

     (setq left-third-screen-pos (list 0.278 my-height-fraction 0 0))    ;last two: 0 from left, 0 from top
     (defun frame-occupy-left-third-screen ()
       "Move and resize the frame so it occupies the left third of the screen."
       (interactive)
       (apply 'frame-move-resize left-third-screen-pos))

                                             ; Set Window size by number of monitors
     (if (window-system)
         (cond
          ((= my-emacs-monitors-num 1)
           (frame-occupy-left-two-thirds-screen))
          ((= my-emacs-monitors-num 2)
           (frame-occupy-left-third-screen))
          (t
           (frame-occupy-left-third-screen))
          )
       )
   #+END_SRC
** Resizing emacs windows
    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<s-up>") 'enlarge-window)
    (global-set-key (kbd "<s-kp-up>") 'enlarge-window)
    (global-set-key (kbd "<s-down>") 'shrink-window)
    (global-set-key (kbd "<s-kp-down>") 'shrink-window)
    (global-set-key (kbd "<s-right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "<s-kp-right>") 'enlarge-window-horizontally)
    (global-set-key (kbd "<s-left>") 'shrink-window-horizontally)
    (global-set-key (kbd "<s-kp-left>") 'shrink-window-horizontally)
    #+END_SRC
** Navigation within and between windows
*** Scrolling
    #+BEGIN_SRC emacs-lisp
                                              ;Scroll with Ctrl+Up/Down
      (defun scroll-dont-move-cursor (dist)
        ""
        (let ((p (point)))
          (scroll-up dist)
          (goto-char p)))

      (defun scroll-up-line ()
        (interactive)
        (scroll-dont-move-cursor 1))

      (defun scroll-down-line ()
        (interactive)
        (scroll-dont-move-cursor -1))

      ;NB: scrolling down = moving the window up...
      (global-set-key (kbd "<C-up>")   'scroll-down-line)
      (global-set-key (kbd "<C-kp-up>")   'scroll-down-line)
      (global-set-key (kbd "<C-down>") 'scroll-up-line)
      (global-set-key (kbd "<C-kp-down>") 'scroll-up-line)

      ; Scroll Other Window with Alt-Up/Down
      (global-set-key (kbd "<M-up>")   (lambda () (interactive) (scroll-other-window-down 1)))
      (global-set-key (kbd "<M-kp-up>")   (lambda () (interactive) (scroll-other-window-down 1)))
      (global-set-key (kbd "<M-down>") (lambda () (interactive) (scroll-other-window-down -1)))
      (global-set-key (kbd "<M-kp-down>") (lambda () (interactive) (scroll-other-window-down -1)))

      ; page-up down works with C- or in the same way as without. NB: M- page up or down work for other 
      ;   window out of the box
      (global-set-key (kbd "<C-prior>")   'scroll-down-command) ;prior = page-up
      (global-set-key (kbd "<C-kp-prior>")   'scroll-down-command)

      (global-set-key (kbd "<C-next>")   'scroll-up-command) ;next = page-down
      (global-set-key (kbd "<C-kp-next>")   'scroll-up-command)

    #+END_SRC
*** Jumping between words
    #+BEGIN_SRC emacs-lisp
                                              ; Change C-arrows to be the same as M-f/b
      (global-set-key (kbd "C-<right>")   'forward-word)
      (global-set-key (kbd "C-<kp-right>")   'forward-word)

      (global-set-key (kbd "C-<left>")   'backward-word)
      (global-set-key (kbd "C-<kp-left>")   'backward-word)

      (global-set-key (kbd "<C-kp-home>")   'beginning-of-buffer)
      (global-set-key (kbd "<C-kp-end>")   'end-of-buffer)

      (global-set-key (kbd "<C-kp-delete>")   'kill-word)


                                              ; Set M-arrows to be the same as C-arrows, but by full words
      (global-set-key (kbd "M-<kp-right>")   'forward-sexp)
      (global-set-key (kbd "M-<kp-left>")   'backward-sexp)
    #+END_SRC
*** Navigation between windows
    #+BEGIN_SRC emacs-lisp
                                              ;Move between Windows
      (global-set-key (kbd "C-x <up>") 'windmove-up)
      (global-set-key (kbd "C-x <down>") 'windmove-down)
      (global-set-key (kbd "C-x <right>") 'windmove-right)
      (global-set-key (kbd "C-x <left>") 'windmove-left)
    #+END_SRC
*** Toggle current window maximization, restore configuration later
    This too was taken from Scott McPeak's "scott.emacs.el"
    #+BEGIN_SRC emacs-lisp
      ; clear this initially
      (setq my-saved-window-config-list nil)

      (defun filter-list (list predicate)
        "Return a list containing only those elements from 'list' which
        cause 'predicate' to return true."
        (if (not list)
            nil          ; recursion base case
            (if (funcall predicate (car list))
                ; keep the item
                (cons (car list) (filter-list (cdr list) predicate))
                ; else, remove it
                (filter-list (cdr list) predicate)
            )))

      ; example of calling filter-list with a lambda function
      ;(filter-list '(1 2 3 4) #'(lambda (n) (> n 2)))

      ; the F5 behavior I want is essentially Windows MDI maximize/restore
      ; toggle -- i.e. what Borland does.
      (defun mdi-maximize-restore-toggle ()
        "When called in a multi-window frame it will save the window
        configuration by calling `current-window-configuration', then call
        `delete-other-windows'.  When called in a single-window frame it will
        restore the frame configuration by calling `set-window-configuration'."
        (interactive)
        (if (> (count-windows) 1)
          (progn    ; multi-window case: maximize
            ; throw away and configs that apply to deleted frames or
            ; the current frame
            (gc-my-window-config-list (selected-frame))

            ; add the config for this frame
            (setq my-saved-window-config-list
              (cons (current-window-configuration) my-saved-window-config-list))

            ; and go to single-window mode
            (delete-other-windows)
          )

          (progn    ; single-window case: restore
            ; search for the config that applies to this frame
            (restore-applicable-window-configuration my-saved-window-config-list)
          )
        ))

      (defun gc-my-window-config-list (frame)
        "Remove any saved configs that apply to deleted frames or to
        the 'frame' argument."
        (setq my-saved-window-config-list
          (filter-list my-saved-window-config-list
            #'(lambda (config)
                (and
                  (member (window-configuration-frame config) (frame-list))
                  (not (eq (window-configuration-frame config) frame))
                ))
          )))

      (defun restore-applicable-window-configuration (list)
        "Look through 'list' for a window config that applies to the selected
        frame.  If found, restore via that config.  If not, say so."
        (if (not list)
          (princ "There is no saved window config for this frame.")
          (if (eq (window-configuration-frame (car list)) (selected-frame))
            ; restore it
            (set-window-configuration (car list))

            ; else, proceed down list
            (restore-applicable-window-configuration (cdr list))
          )))


      ; what I plan to bind F5 to
      (defun intended-mdi-maximize-restore-toggle ()
        "Calls `mdi-maximize-restore-toggle' if it works, otherwise
        calls `delete-other-windows'."
        (interactive)
        (if (functionp 'window-configuration-frame)
          (mdi-maximize-restore-toggle)      ; recent enough emacs (This function already implemented)
          (delete-other-windows)             ; not recent enough.. use old behavior
        ))

      (global-set-key [f5] 'intended-mdi-maximize-restore-toggle)
    #+END_SRC
** Winner mode
    This allows to undo and redo window configurations by C-c-left or C-c-right
    #+BEGIN_SRC 
    (winner-mode 1)
    #+END_SRC
* Plugins
   I try to have my emacs as encapsulated as possible. Thus all the packages I use should be downloaded and added
   to the repository
** Plugin directories
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat emacs-git "Plugins/"))

     (add-to-list 'load-path (concat emacs-git "Plugins/git-modes")) ;various modes required for magit
     (add-to-list 'load-path (concat emacs-git "Plugins/magit"))

     (add-to-list 'load-path (concat emacs-git "Plugins/yasnippet"))

     ;(add-to-list 'load-path (concat emacs-git "Plugins/ein")) ;for python notebook. I didn't manage to make it work

     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode"))
     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode/lisp"))
     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode/contrib/lisp"))
     (add-to-list 'load-path (concat emacs-git "Plugins/autocomplete"))
     (add-to-list 'load-path (concat emacs-git "Plugins/fill-column-indicator-1.83"))
     (add-to-list 'load-path (concat emacs-git "Plugins/swiper"))
   #+END_SRC
** Loading the plugins
*** Magit
    This is the cool git mode for emacs
    #+BEGIN_SRC emacs-lisp
      ;TODO: Get the latest version of Magit from github, and see what has been happening

      (load "magit")
      (require 'magit)

      (global-set-key "\C-ci" 'magit-status)
      (global-set-key "\C-c\C-b" 'magit-blame-mode)

      ; magit-diff-file was written by dov, and requsted to be merged into magit.
      ; See: https://github.com/magit/magit/issues/2553
      (defun magit-diff-file (rev-or-range &optional file args)
        "Show changes between a file from another branch"
        (interactive (list (magit-diff-read-range-or-commit "File diff for range" nil current-prefix-arg)
                           (if current-prefix-arg
                             (read-file-name "File: ")
                             buffer-file-name))) 
        (magit-diff-setup rev-or-range nil args
                          (list (replace-regexp-in-string (magit-toplevel) "" (expand-file-name file)))))

      (global-set-key (kbd "C-c d") 'magit-diff-file)

      ; magit settings
      (setq magit-push-always-verify nil) ; by default push to updtream branch
      (setq git-commit-summary-max-length 256) ; length of commit-msg above which a warning is shown
      (load "magit-blame")
      (load "markdown-mode")
      (setq magit-diff-options '("-w"))
      (load "mo-git-blame")


    #+END_SRC
*** NSIS
    #+BEGIN_SRC emacs-lisp
      (autoload 'nsis-mode "nsis-mode" "NSIS mode" t)
      (setq auto-mode-alist (append '(("\\.\\([Nn][Ss][Ii]\\)$" .
                                       nsis-mode)) auto-mode-alist))
      (setq auto-mode-alist (append '(("\\.\\([Nn][Ss][Hh]\\)$" .
                                       nsis-mode)) auto-mode-alist))
    #+END_SRC
*** lua
    #+BEGIN_SRC emacs-lisp
      (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
      (add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
      (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))
                                              ;(setq lua-indent-level 2)
    #+END_SRC
*** XMSI
    This allows to replace sequences of characters for symbols
    #+BEGIN_SRC emacs-lisp
      (require 'xmsi-math-symbols-input)
      (xmsi-mode)
    #+END_SRC

*** Ido mode
    ido-mode is the cool autocompletion mode in the lower buffer
    #+BEGIN_SRC emacs-lisp
    (require 'ido)
    (ido-mode t)
    #+END_SRC
*** Smex
    Smex uses Ido mode for M-x commands
    #+BEGIN_SRC emacs-lisp
                                              ;smex for using IDO for M-x commands
      (require 'smex) ; Not needed if you use package.el
      (smex-initialize) ; Can be omitted. This might cause a (minimal) delay
                                              ; when Smex is auto-initialized on its first run.
 
      (global-set-key (kbd "M-x") 'smex)
      (global-set-key (kbd "M-X") 'smex-major-mode-commands)
      ;; This is your old M-x.
      (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
    #+END_SRC
*** Ivy
    Ivy is like Ido, but better is /some/ regards
    #+BEGIN_SRC emacs-lisp
      (require 'counsel)
  
      (define-key ivy-minibuffer-map (kbd "C-j") #'ivy-immediate-done)
      (define-key ivy-minibuffer-map (kbd "RET") #'ivy-alt-done)
  
      (global-set-key (kbd "<f1> f") 'counsel-describe-function)
      (global-set-key (kbd "<f1> v") 'counsel-describe-variable)
      (global-set-key (kbd "<f1> l") 'counsel-find-library)
  
      (global-set-key (kbd "<f2> i") 'counsel-info-lookup-symbol)
      (global-set-key (kbd "<f2> u") 'counsel-unicode-char)
  
      (global-set-key (kbd "C-c g") 'counsel-git)
      (global-set-key (kbd "C-c j") 'counsel-git-grep)
    #+END_SRC
*** Undo Tree
    #+BEGIN_SRC emacs-lisp
      (require 'undo-tree)
      (global-undo-tree-mode)
      (set-default 'undo-tree-auto-save-history t)
    #+END_SRC
*** js2 mode for json
    #+BEGIN_SRC emacs-lisp
      (require 'js2-mode)
    #+END_SRC
*** YaSnippet for programming templates
    #+BEGIN_SRC emacs-lisp
      (require 'yasnippet)
      (setq yas-snippet-dirs (list (concat emacs-git "Plugins/yasnippet/snippets")))
      (yas-global-mode 1)

      ;; Completing point by some yasnippet key
      (defun yas-ido-expand ()
        "Lets you select (and expand) a yasnippet key"
        (interactive)
        (let ((original-point (point)))
          (while (and
                  (not (= (point) (point-min) ))
                  (not
                   (string-match "[[:space:]\n]" (char-to-string (char-before)))))
            (backward-word 1))
          (let* ((init-word (point))
                 (word (buffer-substring init-word original-point))
                 (list (yas-active-keys)))
            (goto-char original-point)
            (let ((key (remove-if-not
                        (lambda (s) (string-match (concat "^" word) s)) list)))
              (if (= (length key) 1)
                  (setq key (pop key))
                (setq key (ido-completing-read "key: " list nil nil word)))
              (delete-char (- init-word original-point))
              (insert key)
              (yas-expand)))))


      (define-key yas-minor-mode-map (kbd "C-<return>")     'yas-ido-expand)
      (define-key yas-minor-mode-map (kbd "C-<kp-enter>")     'yas-ido-expand)

      (yas-reload-all)
    #+END_SRC
*** AutoCompletion
    #+BEGIN_SRC emacs-lisp
                                              ; Lexical completion with M-RET
      (define-key yas-minor-mode-map (kbd "M-<return>")     'dabbrev-expand)
      (define-key yas-minor-mode-map (kbd "M-<kp-enter>")     'dabbrev-expand)

                                              ;auto-complete
      (require 'auto-complete-config)
      (add-to-list 'ac-dictionary-directories (concat emacs-git "Plugins/autocomplete/ac-dict"))
      (ac-config-default)

    #+END_SRC
* Modes
** Python Model
   #+BEGIN_SRC emacs-lisp
     ;;;;;;;;;;;;; python-mode - I'll try using the built-in mode that comes with emacs
     ;;;;;;;(setq py-install-directory (concat emacs-git "Plugins/python-mode.el-6.1.2"))
     ;;;;;;;(add-to-list 'load-path py-install-directory)
     ;;;;;;;(setq py-outline-minor-mode-p nil)
     ;;;;;;;(require 'python-mode)

     (global-set-key (kbd "C-M-p") 'python-mode)

     (add-hook 'python-mode-hook
       (lambda ()
         (my-indent-mode))
       )

     ;;TODO: Python indents
   #+END_SRC
* Shell
  #+BEGIN_SRC emacs-lisp
                                            ;Open shell
    (defun open-shell ()
      "Load the emacs shell"
      (interactive)
      (shell)
      )

    (global-set-key [f10] 'open-shell)
                                            ;??
    (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)
  #+END_SRC
* Emacs Env Vars
#+BEGIN_SRC emacs-lisp
  (defun my-reload-env-vars ()
                                          ; set env vars to be reloaded here
    ;; e.g.:  
    ;;  (setenv "METALJET" "$PE_HOME/XjetApps/MetalJet/Apps/Project/qt/" t)
    )

                                          ;Global Env Vars
  (setenv "QMAKE" "qmake-qt5")
  (setenv "QTDIR" "/usr")
                                          ; add env vars according to bashrc...


  `my-reload-env-vars()

#+END_SRC
* Connecting various notebooks to keys
  TL;DR: 
  F8 → Personal Notebook
  F9 → Work Notebook
  C-> → This Init File
  #+BEGIN_SRC emacs-lisp
    (defun buffer-exists (bufname) (not (eq nil (get-buffer bufname))))

                                            ;Work Notebook
    (defun open-work-notes-file ()
      "Load my work notebook"
      (interactive)
      (if (buffer-exists work-notebook-filename)
          (progn
            (message "Switching to Work Notebook")
            (switch-to-buffer personal-notebook-filename)
            )
        (progn
          (message "Opening Work Notebook")
          (find-file default-work-notes-file)
          (font-lock-fontify-buffer)
          (end-of-buffer)
          )
        )
      )

    (global-set-key [f9] 'open-work-notes-file)

                                            ;Personal Notebook
    (defun open-personal-notes-file ()
      "Load my personal notebook"
      (interactive)
      
      (if (buffer-exists personal-notebook-filename)
          (progn
            (message "Switching to Personal Notebook")
            (switch-to-buffer personal-notebook-filename)
            )
        (progn
          (message "Opening Personal Notebook")
          (find-file default-personal-notes-file)
          (font-lock-fontify-buffer)
          (end-of-buffer)
          )
        )
      )

    (global-set-key [f8] 'open-personal-notes-file)

                                            ;Init File
    (defun open-init-file ()
      "Load my personal init file"
      (interactive)
      (if (buffer-exists default-init-filename)
          (progn
            (message "Switching to Default Init File")
            (switch-to-buffer default-init-filename)
            )
        (progn
          (message "Opening Default Init File")
          (find-file default-init-file)
          )
        )
      )

    (global-set-key (kbd "C->") '(lambda () (interactive) 
                                   (open-init-file)
                                   )
                    )
  #+END_SRC
* Command Histories
** Command history completion
   #+BEGIN_SRC emacs-lisp
     (define-key minibuffer-local-map (kbd "M-p") 'previous-complete-history-element)
     (define-key minibuffer-local-map (kbd "M-n") 'next-complete-history-element)
     (define-key minibuffer-local-map (kbd "<up>") 'previous-complete-history-element)
     (define-key minibuffer-local-map (kbd "<down>") 'next-complete-history-element)
   #+END_SRC
** Save history between emacs sessions
   #+BEGIN_SRC emacs-lisp
     (savehist-mode t)
   #+END_SRC
** Comint command history
   Comint is the underlying mode for interpreters, e.g. shell ipython etc.
*** Comint commands browsing
    #+BEGIN_SRC emacs-lisp
      (add-hook 'comint-mode-hook
                (lambda()
                                              ;Browsing commands from history
                  (define-key comint-mode-map [(meta p)] 'comint-previous-matching-input-from-input)
                  (define-key comint-mode-map [(kbd "<up>")] 'comint-previous-matching-input-from-input)

                  (define-key comint-mode-map [(meta n)] 'comint-next-matching-input-from-input)
                  (define-key comint-mode-map [(kbd "<down>")] 'comint-next-matching-input-from-input)

                  (define-key comint-mode-map [(control c) (control o)] 'comint-kill-output-to-kill-ring)
                  (define-key comint-mode-map [(control x) (control ?\\)] 'toggle-backslash-line)
                  (define-key comint-mode-map [(tab)] 'comint-dynamic-complete)

                                              ;Save history when the shell is killed
                  (make-local-variable 'comint-input-ring-file-name)
                  (setq comint-input-ring-file-name (concat emacs-persistance-dir "/comint-history"))
                  (setq comint-input-ring-size 10000)
                  (setq comint-process-echoes 't)
                  (comint-read-input-ring)
                  (make-local-variable 'kill-buffer-hook)
                  (add-hook 'kill-buffer-hook 'comint-write-input-ring) ;this is related to Manzyuk's stuff below
                  )
                )
    #+END_SRC
*** The following comint history recording is based on [[https://oleksandrmanzyuk.wordpress.com/2011/10/23/a-persistent-command-history-in-emacs/][A blog I found by Oleksandr Manzyuk]]
    I'm not sure if it is related to the above
    #+BEGIN_SRC emacs-lisp
     (defun comint-write-history-on-exit (process event)
       (comint-write-input-ring)
       (let ((buf (process-buffer process)))
         (when (buffer-live-p buf)
           (with-current-buffer buf
             (insert (format "\nProcess %s %s" process event))))))

     (defun turn-on-comint-history ()
       (let ((process (get-buffer-process (current-buffer))))
         (when process
           (setq comint-input-ring-file-name
                 (format “~/.emacs.d/inferior-%s-history”
                          (replace-regexp-in-string “/” “%” (process-name process))
                          ))
           (comint-read-input-ring)
           (set-process-sentinel process
                                 #'comint-write-history-on-exit))))

     (add-hook 'shell-mode-hook 'turn-on-comint-history)

     (add-hook 'kill-buffer-hook 'comint-write-input-ring)

     (defun mapc-buffers (fn)
       (mapc (lambda (buffer)
               (with-current-buffer buffer
                 (funcall fn)))
             (buffer-list)))

    (defun comint-write-input-ring-all-buffers ()
      (mapc-buffers 'comint-write-input-ring))

     (add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
   #+END_SRC
* Most Recent Buffers
  #+BEGIN_SRC emacs-lisp
    ;; Most Recent Buffers
    (defun find-first-buffer-match (buffers pattern)
      (dolist (f buffers)
        (when (string-match pattern (buffer-name f))
          (return f))))

    (defun find-most-recent-pattern-buffer (pattern)
      "find the most recent code buffer in the history and switch to it"
      (let ((f (find-first-buffer-match (cdr (buffer-list)) pattern)))
        (if (not (eq f nil))
            (switch-to-buffer f)
          )
        )
      )

    (defun find-most-recent-python-buffer ()
      "find the most recent python buffer in the history and switch to it"
      (interactive)
      (find-most-recent-pattern-buffer "\\.py"))
    (global-set-key (kbd "S-C-p") 'find-most-recent-python-buffer)

    (defun find-most-recent-c-buffer ()
      "find the most recent c/c++ buffer in the history and switch to it"
      (interactive)
      (find-most-recent-pattern-buffer "\\.\\(cpp\\|h\\|cc\\|hh|hpp\\)$"))
    (global-set-key (kbd "S-C-c") 'find-most-recent-c-buffer)

    (defun find-most-recent-emacs-buffer ()
      "find the most recent emacs init buffer in the history and switch to it"
      (interactive)
      (find-most-recent-pattern-buffer "\\.el\\$\\|dov.emacs|SimonInit.el"))
    (global-set-key (kbd "S-C-e") 'find-most-recent-emacs-buffer)

    (defun find-most-recent-org-buffer ()
      "find the most recent code buffer in the history and switch to it"
      (interactive)
      (find-most-recent-pattern-buffer "\\.org\$"))
    (global-set-key (kbd "S-C-o") 'find-most-recent-org-buffer)

    (global-set-key (kbd "C-S-s") '(lambda () (interactive) 
                                     (switch-to-buffer (find-most-recent-pattern-buffer "\\*shell"))))

    (defun find-most-recent-magit-buffer ()
      "find the most recent magit buffer in the history and switch to it"
      (interactive)
      (find-most-recent-pattern-buffer "magit"))
    (global-set-key (kbd "S-C-m") 'find-most-recent-magit-buffer)
  #+END_SRC
* Documentation Lookup
   #+BEGIN_SRC emacs-lisp
                                             ; qt docs lookup
     (require `info-look)
     (load "qtdoc")
     (setq qtdoc-html-root "http://doc.qt.io/qt-5/")
     (global-set-key [(control h) (control q)] 'qtdoc-lookup)

                                             ;google-doc searches google for the various lookup commands
     (load "google-look")

     (global-set-key [(control h) (control g)] 'google-lookup)
     (global-set-key [(control h) (control p)] 'python-lookup)
     (global-set-key [(control h) (control c)] 'cpp-lookup)
   #+END_SRC

* Various Keyboard Shortcuts
** Undo-Redo
   #+BEGIN_SRC emacs-lisp
     (defalias 'redo 'undo-tree-redo)
     (global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
     (global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】;  Mac style
   #+END_SRC
** Disable default exit command
   I trip over it accidentally while undoing and redoing too much
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-x\C-c" nil)
   #+END_SRC
** Windows style commands
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-o" 'counsel-find-file)  ; Open file (Microsoft style) in Ivy instead of Ido

     (global-set-key (kbd "C-<f4>") 'kill-this-buffer) ; Close Buffer (Microsoft style)

     (global-set-key (kbd "C-<tab>") 'next-buffer) ; C-Tab: Next Buffer
     (global-set-key (kbd "C-S-<iso-lefttab>") 'previous-buffer) ; C-S-Tab: Previous Buffer
     (global-set-key (kbd "C-S-<tab>") 'previous-buffer) ; C-S-Tab: Previous Buffer

   #+END_SRC
** Programming
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "RET") 'newline-and-indent) ; For programming language modes

     (global-set-key (kbd "M-g") 'goto-line) ; Goto-line

     (global-set-key (kbd "C-<f9>") 'compile) ; Compile

     (global-set-key "\M-`" 'next-error) ; Next Error (and also next file in dov-git-grep)
     (global-set-key "\M-~" 'previous-error) ; Previous Error (and also previous file in dov-git-grep)
   #+END_SRC
