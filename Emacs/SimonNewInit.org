# -*- Encoding: utf-8 -*-
#+STARTUP: hidestars hideall
#+OPTIONS: ^:{}
#+OPTIONS: TOC:nil

* TODO:
** Something not working in [[ox-slidy]] and [[ox-latex]] → fix it
** Env vars according to bashrc (under [[Emacs Env Vars]])
** python indents (test it) - [[Python Mode]]
** check out latest magit
** IPython? Jupyter?
*** IPython
    TODO: make this work
   #+BEGIN_SRC emacs-lisp
     ;; use IPython
     (setq-default py-shell-name "ipython")
     (setq-default py-which-bufname "IPython")

     ;; use the wx backend, for both mayavi and matplotlib
     (setq py-python-command-args
           '("--gui=wx" "--pylab=wx" "-colors" "Linux"))
     (setq py-force-py-shell-name-p t)

     ;; switch to the interpreter after executing code
     (setq py-shell-switch-buffers-on-execute-p t)
     (setq py-switch-buffers-on-execute-p t)

     ;; don't split windows
     ;;(setq py-split-windows-on-execute-p nil)
   #+END_SRC
  - [ ] Annotate TODO markers?
** Annotate TODO markers
    TODO: make this work?
    #+BEGIN_SRC emacs-lisp
      ;;TODO: Make this work?
      ;;(defun annotate-todo ()
      ;;  "put fringe marker on TODO: lines in the curent buffer"
      ;;  (interactive)
      ;;  (save-excursion
      ;;    (goto-char (point-min))
      ;;    (while (re-search-forward "TODO:" nil t)
      ;;      (let ((overlay (make-overlay (- (point) 5) (point))))
      ;;        (overlay-put overlay 'before-string (propertize "A"
      ;;                                                        'display '(left-fringe right-triangle)))))))
      ;;
      ;;(add-hook 'python-mode-hook 'annotate-todo)
    #+END_SRC
** sudo in shell mode
*** check out [[Shell Mode]]
** root under ido-mode
   Zamansky mentions the possibility of opening file as sudo by opening sudo::FILENAME (*Double Colon!*)
** Path in status bar?
** test image opener on Windows
** Check out WinUtils.el (under [[Windows vs Linux Settings]])
** Go over the rest of scott.emacs.el and delete it
** before-save-hook
** Cheat-sheet
* Introduction
** General
  This is my emacs configuration file, to which I constantly add stuff shamelessly stolen from others.
  I try to attribute wherever I take a big (or significant) chunk of stuff.
** Major Thanks and attributions
*** Dov Grobgeld
    Much of my stuff was taken from (and taught to me by) [[https://www.linkedin.com/in/dovgrobgeld][Dov Grobgeld]] ([[https://github.com/dov][github repository here]])
*** Mark Zamansky
    A lot of additional stuff (including how to organize the init file as an org mode) I learned from [[http://cestlaz.github.io/stories/emacs/][Mark Zamansky's excellent blog on emacs]]
** To use this file, add lines similar to the following to ~/.emacs:
   #+BEGIN_SRC .emacs-file
     ;;This is done to safely ignore local-variables warnings
     (setq enable-local-variables :safe)

     ;;Setting basic location and variables - override those if needed
     (defvar emacs-git
       "/home/simon/github/SimonEnv/Emacs/"
       "The location of my Emacs environment settings")

     (defvar default-work-notes-file
       "/home/simon/github/XJetWorkNotes/WorkNoteBook.org"
       "The location of my Work Notebook (somewhere on the work server?)")

     (defvar default-personal-notes-file
       "/home/simon/Notebook/NoteBook.org"
       "The location of my personal notebook (mounted from EncFS)")

     (defvar default-init-file
       (concat emacs-git "SimonNewInit.org")
       "My Init File")

     (defvar my-emacs-monitors-num 1
       "The number of monitors to take into account when calculating the Emacs window size (2/3 of the
       available width)")

     (defalias `my-indent-mode `my-indent-mode-xjet
       "My Indent Mode")

     ;;emacs persistance directory
     (if (not (boundp 'emacs-persistance-dir))
         (setq emacs-persistance-dir "/home/simon/.emacs.d")
       )

     ;;Loading the rest of the configuration from my environment
     (if (string-equal (file-name-extension default-init-file) "org")
         ;;The new way: via org mode
         (org-babel-load-file default-init-file)

       ;;Else: The old way
       (load default-init-file)
       )
   #+END_SRC
* Setting up the basics
** Default files and directories
  #+BEGIN_SRC emacs-lisp
(if (not (boundp 'default-init-file))
    (defvar default-init-file
      (concat emacs-git "SimonNewInit.org")
      "My Init File")
  )

(defvar default-init-filename
  (file-name-nondirectory default-init-file)
  "Name of the default init file"
  )

(if (boundp 'default-work-notes-file)
    (defvar work-notebook-filename
      (file-name-nondirectory default-work-notes-file)
      "Name of the default Work Notebook")
  )

(if (boundp 'default-personal-notes-file)
    (defvar personal-notebook-filename
      (file-name-nondirectory default-personal-notes-file)
      "Name of the default Personal Notebook")
  )
(if (not (boundp 'my-indent-mode))
    (defalias `my-indent-mode `my-indent-mode-xjet
      "My Indent Mode")
  )
  #+END_SRC
** Number of monitors attached
   #+BEGIN_SRC emacs-lisp
     (if (not (boundp 'my-emacs-monitors-num))
         (defvar my-emacs-monitors-num 1
               "The number of monitors to take into account when
                calculating the Emacs window size (2/3 of the available
                width)") )
   #+END_SRC
** Windows vs Linux Settings
   #+BEGIN_SRC emacs-lisp
     (if (string-match "mingw" system-configuration)
         ;;On Windows
         (progn
           (if (not (boundp 'emacs-git))
               (defvar emacs-git "D:/Simon/github/SimonEnv/Emacs/"
                 "/home/simon/github/SimonEnv/Emacs/"
                 "The location of my Emacs environment settings"))
           (if (not (boundp 'emacs-persistance-dir))
               (setq emacs-persistance-dir "C:/Documents and Settings/simon/Application Data/.emacs.d"))

           ;; don't use Hebrew locale!
           (setq system-time-locale "C")

           ;; Load windows utilities - those include send buffer to VS by Dov.
           ;; TODO: Check this out
           ;;      (load (concat emacs-git "win-utils.el")))

           ;; Various settings to use utf-8 (From Dov, I don't understand them all)
           (setq utf-translate-cjk-mode nil) ; disable CJK coding/encoding (Chinese/Japanese/Korean characters)
           (set-language-environment 'utf-8)
           (setq locale-coding-system 'utf-8)
           (set-default-coding-systems 'utf-8)
           (set-terminal-coding-system 'utf-8)
           (prefer-coding-system 'utf-8)

           ;; Add M-F4 to closing emacs, as apparently it is not caught by the windows manager
           (global-set-key (kbd "M-<f4>") 'save-buffers-kill-terminal) ; Close EMACS (Microsoft style)

           ;; Chrome command for windows (assumes C:\Program Files (x86)\Google\Chrome\Application is in path)
           (if (not (boundp 'my-chrome-command))
               (defvar my-chrome-command "chrome" "The command to run Google-Chrome"))

           )
                                             ;On Linux
       (progn

         (if (not (boundp 'emacs-git))
             (defvar emacs-git "/home/simon/github/SimonEnv/Emacs/"
               "/home/simon/github/SimonEnv/Emacs/"
               "The location of my Emacs environment settings"))

         (if (not (boundp 'emacs-persistance-dir))
             (setq emacs-persistance-dir "/home/simon/.emacs.d"))

         ;; Use Miriam mono font for Hebrew (???)
         (set-fontset-font "fontset-default" '(#x5d0 . #x5ff) "Miriam Mono CLM:bold")
         (set-face-font 'default "fontset-default")
         (setq load-path (append (list
                                  "/usr/local/share/emacs/site-lisp"
                                  ) load-path))

         ;; Chrome command for linux
         (if (not (boundp 'my-chrome-command))
             (defvar my-chrome-command "google-chrome" "The command to run Google-Chrome"))
         (setq browse-url-generic-program "google-chrome")
         )
       )
   #+END_SRC
** Fonts
   I use the "InconsolataDov" font size 11 for code. This font (located [[file:InconsolataDov.ttf][in the repository]]) must be installed
   - On Windows - double click the font
   - On Linux - just copy it into file:~/.fonts/ (create dir if necessary)
#+BEGIN_SRC emacs-lisp
  (add-to-list 'default-frame-alist '(font .   "InconsolataDov 11"))
  (set-face-attribute 'default t :font  "InconsolataDov 11" )

  (set-face-attribute 'default nil :font  "InconsolataDov 11" )
  (set-frame-font   "InconsolataDov 11" nil t)

  (setq my-default-family "InconsolataDov 11")
  (setq my-default-font "InconsolataDov 11")
#+END_SRC
* Plugins
  I try to have my emacs as encapsulated as possible. Thus all the packages I use should be downloaded and added
   to the repository
** Plugin directories
   #+BEGIN_SRC emacs-lisp
     (add-to-list 'load-path (concat emacs-git "Plugins/"))

     (add-to-list 'load-path (concat emacs-git "Plugins/git-modes")) ;various modes required for magit
     (add-to-list 'load-path (concat emacs-git "Plugins/magit"))

     (add-to-list 'load-path (concat emacs-git "Plugins/yasnippet"))

                                             ;(add-to-list 'load-path (concat emacs-git "Plugins/ein")) ;for python notebook. I didn't manage to make it work

     (add-to-list 'load-path (concat emacs-git "Plugins/plantuml-mode"))

     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode"))
     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode/lisp"))
     (add-to-list 'load-path (concat emacs-git "Plugins/org-mode/contrib/lisp"))

     (add-to-list 'load-path (concat emacs-git "Plugins/autocomplete"))

     (add-to-list 'load-path (concat emacs-git "Plugins/fill-column-indicator-1.83"))

     (add-to-list 'load-path (concat emacs-git "Plugins/swiper"))

     (add-to-list 'load-path (concat emacs-git "Plugins/expand-region"))

     (add-to-list 'load-path (concat emacs-git "Plugins/multiple-cursors"))

     (add-to-list 'load-path (concat emacs-git "Plugins/projectile"))

     (add-to-list 'load-path (concat emacs-git "Plugins/counsel-projectile"))
   #+END_SRC
** Loading the plugins
*** Move-Border for window resizing
    This (by an unknown author, found at [[https://github.com/ramnes/move-border][ramnes' github]]) allows a general approach to resizing emacs windows
    #+BEGIN_SRC emacs-lisp
      (load "move-border.el")
    #+END_SRC
*** Magit
    This is the cool git mode for emacs
    #+BEGIN_SRC emacs-lisp
      ;;TODO: Get the latest version of Magit from github, and see what has been happening
      (load "magit")
      (require 'magit)

      (global-set-key "\C-ci" 'magit-status)
      (global-set-key "\C-c\C-b" 'magit-blame-mode)

      ;; magit-diff-file was written by dov, and requsted to be merged into magit.
      ;; See: https://github.com/magit/magit/issues/2553
      (defun magit-diff-file (rev-or-range &optional file args)
        "Show changes between a file from another branch"
        (interactive (list (magit-diff-read-range-or-commit "File diff for range" nil current-prefix-arg)
                           (if current-prefix-arg
                               (read-file-name "File: ")
                             buffer-file-name)))
        (magit-diff-setup rev-or-range nil args
                          (list (replace-regexp-in-string (magit-toplevel) "" (expand-file-name file)))))

      (global-set-key (kbd "C-c d") 'magit-diff-file)

      ;; magit settings
      (setq magit-push-always-verify nil) ; by default push to updtream branch
      (setq git-commit-summary-max-length 256) ; length of commit-msg above which a warning is shown
      (load "magit-blame")
      (load "markdown-mode")
      (setq magit-diff-options '("-w"))
      (load "mo-git-blame")
    #+END_SRC
*** git-modes
    Those are various git-related modes (e.g. .gitattributes, .gitignore files etc)
    #+BEGIN_SRC emacs-lisp
      (require 'git-modes)
    #+END_SRC
*** NSIS
    #+BEGIN_SRC emacs-lisp
      (autoload 'nsis-mode "nsis-mode" "NSIS mode" t)
    #+END_SRC
*** lua
    #+BEGIN_SRC emacs-lisp
      (autoload 'lua-mode "lua-mode" "Lua editing mode." t)
      (add-to-list 'interpreter-mode-alist '("lua" . lua-mode))

    #+END_SRC
*** XMSI
    This allows to replace sequences of characters for symbols
    #+BEGIN_SRC emacs-lisp
      (require 'xmsi-math-symbols-input)
      (xmsi-mode)
    #+END_SRC
*** Ido mode
    ido-mode is the cool autocompletion mode in the lower buffer
    #+BEGIN_SRC emacs-lisp
      (require 'ido)
      (ido-mode t)

      ;; Allow sudo in ido-find-file  !!!
      (defadvice ido-find-file (after find-file-sudo activate)
        "Find file as root if necessary."
        (unless (and buffer-file-name
                     (file-writable-p buffer-file-name))
          (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

    #+END_SRC
*** Smex
    Smex uses Ido mode for M-x commands
    #+BEGIN_SRC emacs-lisp
                                              ;smex for using IDO for M-x commands
      (require 'smex) ; Not needed if you use package.el
      (smex-initialize) ; Can be omitted.
      ;;          This might cause a (minimal) delay when Smex is auto-initialized on its first run.

      (global-set-key (kbd "M-x") 'smex)
      (global-set-key (kbd "M-X") 'smex-major-mode-commands)
      ;; This is your old M-x.
      (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
    #+END_SRC
*** Ivy
    Ivy is like Ido, but better is /some/ regards. I use it for opening files, but not for M-x or switch-to-buffer
    #+BEGIN_SRC emacs-lisp
      (require 'counsel)
      ;;Try out the swiper search
      (global-set-key (kbd "C-M-s") 'swiper)

      (define-key ivy-minibuffer-map (kbd "C-j") 'ivy-immediate-done)
      (define-key ivy-minibuffer-map (kbd "RET") 'ivy-alt-done)

      (global-set-key (kbd "C-c u") 'counsel-unicode-char)

      (global-set-key (kbd "C-x b") 'ivy-switch-buffer)

      (global-set-key (kbd "C-c g") 'counsel-git)
      (global-set-key (kbd "C-c j") 'counsel-git-grep) ;useful for finding a single occurrence (compare to Dov's git grep)

      (global-set-key (kbd "M-y") 'counsel-yank-pop) ;using counsel to select from kill ring
      (define-key ivy-minibuffer-map (kbd "M-y") 'ivy-next-line)
    #+END_SRC
*** Undo Tree
    #+BEGIN_SRC emacs-lisp
      (require 'undo-tree)
      (global-undo-tree-mode)
      (set-default 'undo-tree-auto-save-history t)
    #+END_SRC
*** js2 mode for json
    #+BEGIN_SRC emacs-lisp
      (require 'js2-mode)
    #+END_SRC
*** YaSnippet for programming templates
    #+BEGIN_SRC emacs-lisp
      (require 'yasnippet)
      (setq yas-snippet-dirs (list (concat emacs-git "Plugins/yasnippet/snippets")))
      (yas-global-mode 1)


      ;; Completing point by some yasnippet key
      (defun yas-ido-expand ()
        "Lets you select (and expand) a yasnippet key"
        (interactive)
        (let ((original-point (point)))
          (while (and
                  (not (= (point) (point-min) ))
                  (not
                   (string-match "[[:space:]\n]" (char-to-string (char-before)))))
            (backward-word 1))
          (let* ((init-word (point))
                 (word (buffer-substring init-word original-point))
                 (list (yas-active-keys)))
            (goto-char original-point)
            (let ((key (remove-if-not
                        (lambda (s) (string-match (concat "^" word) s)) list)))
              (if (= (length key) 1)
                  (setq key (pop key))
                (setq key (ido-completing-read "key: " list nil nil word)))
              (delete-char (- init-word original-point))
              (insert key)
              (yas-expand)))))


      (define-key yas-minor-mode-map (kbd "TAB")    nil)

      (define-key yas-minor-mode-map (kbd "C-<return>")     'yas-ido-expand)
      (define-key yas-minor-mode-map (kbd "C-<kp-enter>")     'yas-ido-expand)

      (yas-reload-all)
    #+END_SRC
*** AutoCompletion
    #+BEGIN_SRC emacs-lisp
      ;; Lexical completion with M-RET
      (global-set-key (kbd "M-<return>")     'dabbrev-expand)
      (global-set-key (kbd "M-<kp-enter>")     'dabbrev-expand)

      ;;auto-complete
      (require 'auto-complete-config)
      (add-to-list 'ac-dictionary-directories
                   (concat emacs-git "Plugins/autocomplete/ac-dict"))
      (ac-config-default)
    #+END_SRC
*** BitBake
    #+BEGIN_SRC emacs-lisp
      (require 'bb-mode)
    #+END_SRC
*** Fill Column Indicator
    This shows the line at what I expect to be the line width (100 by default)
   #+BEGIN_SRC emacs-lisp
     (require 'fill-column-indicator)

     (define-globalized-minor-mode
       global-fci-mode fci-mode (lambda () (fci-mode 1)))

     (global-fci-mode t)

     (setq-default fill-column 100)
   #+END_SRC
*** dov-git-grep for advanced git search
   #+BEGIN_SRC emacs-lisp
     (load "dov-git-grep")

     ;; git grep
     (global-set-key (kbd "C-c F") 'dov-git-grep)

     ;; git grep, case insensitive
     ;;useful for finding a sequence across many files, with M-~ and M-` for next and previous file
     (global-set-key (kbd "C-c f") 'dov-git-grep-case-insensitive)
   #+END_SRC
*** git-find-file
    this is used to both find a file in a repo (I'm currently not using it and trying the IVY way)
    and as a basis for dov-git-grep (which I am using to allow for M-~ etc)
    #+BEGIN_SRC emacs-lisp
      (load "git-find-file.el")
      ;;I'm experimenting with Ivy for a while
      ;;(global-set-key [(control c) ?g] 'git-find-file)
    #+END_SRC
*** plantuml
    #+BEGIN_SRC emacs-lisp
      (require 'plantuml-mode)
    #+END_SRC
*** python pickle-mode (from Dov)
    #+BEGIN_SRC emacs-lisp
    (load "pickle-mode.el")
    #+END_SRC
*** multiple-cursors
    A very powerful tool I need to experiment with
    #+BEGIN_SRC emacs-lisp
      (require 'multiple-cursors)

      (global-set-key (kbd "C-S-s") 'mc/mark-next-like-this)
      (global-set-key (kbd "C-S-r") 'mc/mark-previous-like-this)
      (global-set-key (kbd "C-S-a") 'mc/mark-all-like-this)
    #+END_SRC
*** Projectile for limiting the commands to the current project
    Based on .git or similar files
    #+BEGIN_SRC emacs-lisp
      (require 'counsel-projectile)
      (projectile-global-mode)
      (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
    #+END_SRC
* GUI and Visuals
** Misc small things
   #+BEGIN_SRC emacs-lisp
     ;;Toolbars
     (setq menu-bar-mode 't)
     (tool-bar-mode 0)

     ;;(non) Blinking Cursor
     (blink-cursor-mode 0)

     ;;Show row and column in a mini-mode
     (column-number-mode t)
     (line-number-mode t)

     ;;Skip the annoying startup screen
     (setq inhibit-startup-screen t)

     ;;Mark correspondind parentheses
     (show-paren-mode t)

     ;;Overwrite Selection
     (delete-selection-mode t)

     ;;Reload changed files
     (global-auto-revert-mode t)

     ;;Don't add newline at end of file
     (setq mode-require-final-newline nil)

     ;;Save clipboard in emacs kill ring before overwriting it
     (setq save-interprogram-paste-before-kill t)
   #+END_SRC
** Invert colors for my emacs editor
   #+BEGIN_SRC emacs-lisp
     ;; Invert Colors only on the first time emacs is run
     (if (not (boundp 'my-do-invert-color))
         (defvar my-do-invert-color t "Is color inversion is required (only once)"))

     (if my-do-invert-color
         (progn
           (invert-face 'default)
           (custom-set-faces `(cursor ((t (:background "white")))))
           (setq my-do-invert-color nil)
           )
       )
   #+END_SRC
** Emacs main window size
   #+BEGIN_SRC emacs-lisp
     ;;Emacs window size
     ;The following was taken from Scott McPeak's "scott.emacs.el". Thank you Scott
     ; ---------------- frame move/resize (i.e. X window) -----------------------
     (defun frame-move-resize
         (width-fraction height-fraction      ; fractions of screen width, height
                         horiz-pos vert-pos)                 ; pels from left, top (neg: right, bot)
       "Move and resize the frame so its width and height are the given
       fractional amounts of the screen width and height, and it is positioned
       from the left (negative: right) and top (negative: bottom) edges by
       the specified number of pixels."
       (if window-system
           (let* ((char-width (frame-char-width))          ; character width in pels
                  (char-height (frame-char-height))        ; char height
                  (disp-width (x-display-pixel-width))     ; screen width in pels
                  (disp-height (x-display-pixel-height))   ; screen height
                  (frame (selected-frame))                 ; frame to act upon
                  (new-columns
                   (round (/ (* disp-width width-fraction) char-width)))
                  (new-lines
                   (round (/ (* disp-height height-fraction) char-height)))
                  )
             (set-frame-size frame new-columns new-lines)  ; do actual resize
             (sleep-for 0.5)                               ; see below
             (set-frame-position frame horiz-pos vert-pos) ; and move (after resize)

             ;; There is a bug where sometimes, inexplicably, the window appears
             ;; shifted about halfway off the right edge of the screen.  I have no
             ;; idea which software the bug is in (emacs, X server, KDE, ...).
             ;; It can be reliably reproduced by running, in sequence:
             ;;   `frame-occupy-normal-position'
             ;;   `frame-occupy-normal-position'
             ;;   `frame-occupy-right-half-screen'
             ;;   `frame-occupy-normal-position'        ; here it will be bad
             ;;   `frame-occupy-normal-position'        ; one more gets it back ok
             ;;
             ;; Update:  On a hunch it was (at least partially) a race condition
             ;; I've inserted a 0.1 second delay between resize and move, and this
             ;; has cured the problem (at least when running on my system with emacs
             ;; running on the same machine as the X server).
             ;;
             ;; Faster machine, longer delay (?): 0.2 secs works now..
             ;; Then again, no delay at all also works!  cool.
             ;; no it doesn't.. but the delay doesn't help..
             ;; nothing works except doing it twice...
             )
         ))

     (setq my-height-fraction 1) ;use the entire screen height

     ;;For one monitor
     (setq left-two-thirds-screen-pos (list 0.6 my-height-fraction 0 0))    ;last two: 0 from left, 0 from top
     (defun frame-occupy-left-two-thirds-screen ()
       "Move and resize the frame so it occupies the left ⅔ of the screen."
       (interactive)
       (apply 'frame-move-resize left-two-thirds-screen-pos))

     ;;For 2 monitors
     (setq left-third-screen-pos (list 0.278 my-height-fraction 0 0))    ;last two: 0 from left, 0 from top
     (defun frame-occupy-left-third-screen ()
       "Move and resize the frame so it occupies the left third of the screen."
       (interactive)
       (apply 'frame-move-resize left-third-screen-pos))

     ;;For 3 monitors
     (setq left-sixth-screen-pos (list 0.21 my-height-fraction 0 0))    ; 0 from left, 0 from top
     (defun frame-occupy-left-sixth-screen ()
       "Move and resize the frame so it occupies the left half of the screen."
       (interactive)
       (apply 'frame-move-resize left-sixth-screen-pos))

                                             ; Set Window size by number of monitors
     (if (window-system)
         (cond
          ((= my-emacs-monitors-num 1)
           (frame-occupy-left-two-thirds-screen))
          ((= my-emacs-monitors-num 2)
           (frame-occupy-left-third-screen))
          ((= my-emacs-monitors-num 3)
           (frame-occupy-left-sixth-screen))
          (t ;;default behaviour: 2 monitors
           (frame-occupy-left-third-screen))
          )
       )
   #+END_SRC
** Resizing emacs windows
    #+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "<C-S-up>")       'move-border-up)
    (global-set-key (kbd "<C-S-kp-up>")    'move-border-up)
    (global-set-key (kbd "<C-S-down>")     'move-border-down)
    (global-set-key (kbd "<C-S-kp-down>")  'move-border-down)
    (global-set-key (kbd "<C-S-right>")    'move-border-right)
    (global-set-key (kbd "<C-S-kp-right>") 'move-border-right)
    (global-set-key (kbd "<C-S-left>")     'move-border-left)
    (global-set-key (kbd "<C-S-kp-left>")  'move-border-left)
    #+END_SRC
** Navigation within and between windows
*** Scrolling
    #+BEGIN_SRC emacs-lisp
      ;;Scroll with Ctrl+Up/Down
      (defun scroll-dont-move-cursor (dist)
        ""
        (let ((p (point)))
          (scroll-up dist)
          (goto-char p)))

      (defun scroll-up-line ()
        (interactive)
        (scroll-dont-move-cursor 1))

      (defun scroll-down-line ()
        (interactive)
        (scroll-dont-move-cursor -1))

      ;;NB: scrolling down = moving the window up...
      (global-set-key (kbd "<C-up>")   'scroll-down-line)
      (global-set-key (kbd "<C-kp-up>")   'scroll-down-line)
      (global-set-key (kbd "<C-down>") 'scroll-up-line)
      (global-set-key (kbd "<C-kp-down>") 'scroll-up-line)

      ;; Scroll Other Window with Alt-Up/Down
      (global-set-key (kbd "<M-up>")
                      (lambda () (interactive) (scroll-other-window-down 1)))

      (global-set-key (kbd "<M-kp-up>")
                      (lambda () (interactive) (scroll-other-window-down 1)))
      (global-set-key (kbd "<M-down>")
                      (lambda () (interactive) (scroll-other-window-down -1)))
      (global-set-key (kbd "<M-kp-down>")
                      (lambda () (interactive) (scroll-other-window-down -1)))

      ;; page-up down works with C- or in the same way as without. NB: M- page up or down work for other
      ;;                                                                  window out of the box
      (global-set-key (kbd "<C-prior>")   'scroll-down-command) ;prior = page-up
      (global-set-key (kbd "<C-kp-prior>")   'scroll-down-command)

      (global-set-key (kbd "<C-next>")   'scroll-up-command) ;next = page-down
      (global-set-key (kbd "<C-kp-next>")   'scroll-up-command)
    #+END_SRC
*** Jumping between words
    #+BEGIN_SRC emacs-lisp
      ;;Subwork mode for jumping by camelback
      (global-subword-mode t) ;Subword Mode - Jump by camelback

      ;; Change C-arrows to be the same as M-f/b
      (global-set-key (kbd "C-<right>")   'forward-word)
      (global-set-key (kbd "C-<kp-right>")   'forward-word)

      (global-set-key (kbd "C-<left>")   'backward-word)
      (global-set-key (kbd "C-<kp-left>")   'backward-word)

      (global-set-key (kbd "<C-kp-home>")   'beginning-of-buffer)
      (global-set-key (kbd "<C-kp-end>")   'end-of-buffer)

      (global-set-key (kbd "<C-kp-delete>")   'kill-word)

      ;; Set M-arrows to be the same as C-arrows, but by full words
      (global-set-key (kbd "M-<kp-right>")   'forward-sexp)
      (global-set-key (kbd "M-<kp-left>")   'backward-sexp)
    #+END_SRC
*** Navigation between windows
    #+BEGIN_SRC emacs-lisp
      ;;Move between Windows
      (global-set-key (kbd "C-x <up>") 'windmove-up)
      (global-set-key (kbd "C-x <down>") 'windmove-down)
      (global-set-key (kbd "C-x <right>") 'windmove-right)
      (global-set-key (kbd "C-x <left>") 'windmove-left)
    #+END_SRC
*** Toggle current window maximization, restore configuration later
    This too was taken from Scott McPeak's "scott.emacs.el"
    #+BEGIN_SRC emacs-lisp
      ; clear this initially
      (setq my-saved-window-config-list nil)

      (defun filter-list (list predicate)
        "Return a list containing only those elements from 'list' which
        cause 'predicate' to return true."
        (if (not list)
            nil          ; recursion base case
            (if (funcall predicate (car list))
                ; keep the item
                (cons (car list) (filter-list (cdr list) predicate))
                ; else, remove it
                (filter-list (cdr list) predicate)
            )))

      ; example of calling filter-list with a lambda function
      ;(filter-list '(1 2 3 4) #'(lambda (n) (> n 2)))

      ; the F5 behavior I want is essentially Windows MDI maximize/restore
      ; toggle -- i.e. what Borland does.
      (defun mdi-maximize-restore-toggle ()
        "When called in a multi-window frame it will save the window
        configuration by calling `current-window-configuration', then call
        `delete-other-windows'.  When called in a single-window frame it will
        restore the frame configuration by calling `set-window-configuration'."
        (interactive)
        (if (> (count-windows) 1)
          (progn    ; multi-window case: maximize
            ; throw away and configs that apply to deleted frames or
            ; the current frame
            (gc-my-window-config-list (selected-frame))

            ; add the config for this frame
            (setq my-saved-window-config-list
              (cons (current-window-configuration) my-saved-window-config-list))

            ; and go to single-window mode
            (delete-other-windows)
          )

          (progn    ; single-window case: restore
            ; search for the config that applies to this frame
            (restore-applicable-window-configuration my-saved-window-config-list)
          )
        ))

      (defun gc-my-window-config-list (frame)
        "Remove any saved configs that apply to deleted frames or to
        the 'frame' argument."
        (setq my-saved-window-config-list
          (filter-list my-saved-window-config-list
            #'(lambda (config)
                (and
                  (member (window-configuration-frame config) (frame-list))
                  (not (eq (window-configuration-frame config) frame))
                ))
          )))

      (defun restore-applicable-window-configuration (list)
        "Look through 'list' for a window config that applies to the selected
        frame.  If found, restore via that config.  If not, say so."
        (if (not list)
          (princ "There is no saved window config for this frame.")
          (if (eq (window-configuration-frame (car list)) (selected-frame))
            ; restore it
            (set-window-configuration (car list))

            ; else, proceed down list
            (restore-applicable-window-configuration (cdr list))
          )))


      ; what I plan to bind F5 to
      (defun intended-mdi-maximize-restore-toggle ()
        "Calls `mdi-maximize-restore-toggle' if it works, otherwise
        calls `delete-other-windows'."
        (interactive)
        (if (functionp 'window-configuration-frame)
          (mdi-maximize-restore-toggle)      ; recent enough emacs (This function already implemented)
          (delete-other-windows)             ; not recent enough.. use old behavior
        ))

      (global-set-key [f5] 'intended-mdi-maximize-restore-toggle)
    #+END_SRC
** Winner mode
    This allows to undo and redo window configurations by C-c-left or C-c-right
    #+BEGIN_SRC emacs-lisp
    (winner-mode 1)
    #+END_SRC
** Ibuffer
   ibuffer is an interactive version of switch buffer (with selection)
   (C-x b) for switch buffer (with ido)
   (C-x C-b) for selecting the buffer + more info
   #+BEGIN_SRC emacs-lisp
     (defalias 'list-buffers 'ibuffer-other-window) ; make ibuffer default

     (setq ibuffer-saved-filter-groups
           (quote (("default"

                    ("dired" (mode . dired-mode))

                    ("org" (name . "^.*org$"))

                    ("json" (mode . js2-mode))

                    ("shell" (or (mode . eshell-mode) (mode . shell-mode)))

                    ("mu4e" (name . "\*mu4e\*"))

                    ("programming" (or
                                    (mode . python-mode)
                                    (mode . c-mode)
                                    (mode . c++-mode)
                                    (mode . lua-mode)
                                    (mode . c++-mode)
                                    ))
                    ("emacs" (or
                              (name . "^\\*scratch\\*$")
                              (name . "^\\*Messages\\*$")))
                    ))))

     (add-hook 'ibuffer-mode-hook
               (lambda ()
                 (ibuffer-auto-mode 1)
                 (ibuffer-switch-to-saved-filter-groups "default")))

     ;; don't show these
                                             ;(add-to-list 'ibuffer-never-show-predicates "zowie")
     ;; Don't show filter groups if there are no buffers in that group
     (setq ibuffer-show-empty-filter-groups nil)

     ;; Don't ask for confirmation to delete marked buffers
     (setq ibuffer-expert t)
   #+END_SRC
** Beacon Mode
   This lights upthe curson on window move
   #+BEGIN_SRC emacs-lisp
     (require 'beacon)
     (beacon-mode 1)
   #+END_SRC
** Expand Region
   Semantic expansion of selection
   #+BEGIN_SRC emacs-lisp
     (require 'expand-region)
     (global-set-key (kbd "C-=") 'er/expand-region)
     (global-set-key (kbd "C--") 'er/contract-region)
   #+END_SRC
** y/n for yes/no
   #+BEGIN_SRC emacs-lisp
   (fset 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
** Narrow or Widen DWIM
   *Do What I Mean* for Narrow or Widen
   This narrows on the relevant part(region, org-src-block, org-subtree, or
     defun, whichever applies first)
   I took this from Mike Zamansky, who quoted it from [[http://endlessparentheses.com/][Endless Parentheses]]
   #+BEGIN_SRC emacs-lisp
     (defun narrow-or-widen-dwim (p)
       "Widen if buffer is narrowed, narrow-dwim otherwise.
          Dwim means: region, org-src-block, org-subtree, or
          defun, whichever applies first. Narrowing to
          org-src-block actually calls `org-edit-src-code'.

          With prefix P, don't widen, just narrow even if buffer
          is already narrowed."
       (interactive "P")
       (declare (interactive-only))
       (cond ((and (buffer-narrowed-p) (not p)) (widen))
             ((region-active-p)
              (narrow-to-region (region-beginning)
                                (region-end)))
             ((derived-mode-p 'org-mode)
              ;; `org-edit-src-code' is not a real narrowing
              ;; command. Remove this first conditional if
              ;; you don't want it.
              (cond ((ignore-errors (org-edit-src-code) t)
                     (delete-other-windows))
                    ((ignore-errors (org-narrow-to-block) t))
                    (t (org-narrow-to-subtree))))
             ((derived-mode-p 'latex-mode)
              (LaTeX-narrow-to-environment))
             (t (narrow-to-defun))))

     ;; This line actually replaces Emacs' entire narrowing
     ;; keymap, that's how much I like this command. Only
     ;; copy it if that's what you want.
     (define-key ctl-x-map "n" #'narrow-or-widen-dwim)
   #+END_SRC
* Indentations
  #+BEGIN_SRC emacs-lisp
    (defun update-indent-mode ()

      (setq standard-indent my-indent)

      ;; c/c++
      (setq c-basic-offset my-c-indent)
      (c-set-offset 'substatement my-substatement)
      (c-set-offset 'substatement-open my-substatement-open)
      (c-set-offset 'access-label my-access-label)
      (c-set-offset 'topmost-intro my-topmost-intro)

      (setq c-basic-indent my-indent)

      ;; Python
      (setq py-indent-offset my-indent)
      (setq python-indent my-indent)
      (setq python-indent-offset my-indent)

      ;; Perl
      (setq perl-indent-level my-indent)

      ;; lua
      (setq lua-indent-level my-indent)
      )

    (defun my-indent-mode-xjet ()
      "Set indent tabs to the xjet indent mode"
      (interactive)

      ;;general
      (setq my-indent 2)

      ;; C++
      (setq my-c-indent 2)
      (setq my-substatement 2)
      (setq my-substatement-open 0)
      (setq my-access-label 0)
      (setq my-topmost-intro 0)

      (update-indent-mode)
      )

    (defun my-indent-mode-cree ()
      "Set indent tabs to the xjet indent mode"
      (interactive)
      ;; C++
      (setq my-indent 4)
      (setq my-substatement 4)
      (setq my-substatement-open 0)
      (setq my-access-label 0)
      (setq my-topmost-intro 0)
      (update-indent-mode)

      ;; Python - override
      (setq python-indent-offset 2)
      )

  #+END_SRC
* Modes
  TL;DR:
  F10    → shell mode
  C-M-p → python mode
  C-M-t → text mode
  C-M-c → c++ mode
** Python Mode
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-M-p") 'python-mode)

     (add-hook 'python-mode-hook
       (lambda ()
         (my-indent-mode))
       )

     ;;TODO: Python indents

     ;; try to automagically figure out indentation
     (setq py-smart-indentation t)
   #+END_SRC
** Lua Mode
   #+BEGIN_SRC emacs-lisp
     (add-hook 'lua-mode-hook
          (lambda ()
            (my-indent-mode))
          )
   #+END_SRC
** Shell Mode
   #+BEGIN_SRC emacs-lisp
     ;;Open shell
     (defun open-shell ()
       "Load the emacs shell"
       (interactive)
       (shell)
       )

     (global-set-key [f10] 'open-shell)

     ;;??
     (add-hook 'shell-mode-hook 'ansi-color-for-comint-mode-on)

     ;; Allow sudo in shell command  !!!
     ;;TODO: make this work?
     ;;(defun sudo-shell-command (command)
     ;;  (shell-command (concat "echo " (read-passwd "Password: ") " | sudo -S " command)))
     ;;
     ;;(global-set-key (kbd "C-M-!") 'sudo-shell-command(command))
   #+END_SRC
** Text Mode
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-M-t") 'text-mode)

     ;;Text mode indent
     (defun newline-and-indent-relative()
     "Do a newline and a relative indent."
     (interactive)
     (newline)
     (indent-relative-maybe))

     (define-key text-mode-map [return] 'newline-and-indent-relative)
   #+END_SRC
** c++ Mode
*** general
   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "C-M-C") 'c++-mode)

     (global-set-key (kbd "C-M-{") 'c-beginning-of-defun) ; something like matching function
     (global-set-key (kbd "C-M-}") 'c-end-of-defun)

     ;;switch between header and src files
     (add-hook 'c-mode-common-hook
     (lambda()
     (local-set-key  (kbd "C-c h") 'ff-find-other-file)))
   #+END_SRC
*** find matching paren of any type
      This too was taken from Scott McPeak's "scott.emacs.el"
    #+BEGIN_SRC emacs-lisp
      (defun find-matching-keyword ()
        "Find the matching keyword of a balanced pair."
        (interactive)
        (cond
                                              ; these first two come from lisp/emulation/vi.el
         ((looking-at "[[({]") (forward-sexp 1) (backward-char 1))
         ((looking-at "[])}]") (forward-char 1) (backward-sexp 1))

                                              ; TODO: Should the set of pairs be sensitive to the mode of
                                              ; the current file?

                                              ; Kettle CVC
         ((looking-at "ASSERT")
          (find-matching-element 're-search-forward 6 "ASSERT" "RETRACT"))
         ((looking-at "RETRACT")
          (find-matching-element 're-search-backward 0 "RETRACT" "ASSERT"))

                                              ; Kettle CVC
                                              ;
                                              ; "\\b": word boundary assertion, needed because one delimiter is
                                              ; a substring of the other
         ((looking-at "BLOCK")
          (find-matching-element 're-search-forward 5 "\\bBLOCK\\b" "ENDBLOCK"))
         ((looking-at "ENDBLOCK")
          (find-matching-element 're-search-backward 0 "ENDBLOCK" "\\bBLOCK\\b"))

                                              ; Simplify
         ((looking-at "BG_PUSH")
          (find-matching-element 're-search-forward 7 "BG_PUSH" "BG_POP"))
         ((looking-at "BG_POP")
          (find-matching-element 're-search-backward 0 "BG_POP" "BG_PUSH"))

                                              ; C/C++
         ((looking-at "#if")
          (find-matching-element 're-search-forward 3 "#if" "#endif"))
         ((looking-at "#endif")
          (find-matching-element 're-search-backward 0 "#endif" "#if"))

                                              ; ML
                                              ;
                                              ; this does not quite work because e.g. "struct" is also terminated
                                              ; with "end" ..
         ((looking-at "begin")
          (find-matching-element 're-search-forward 5 "\\bbegin\\b" "\\bend\\b"))
         ((looking-at "end")
          (find-matching-element 're-search-backward 0 "\\bend\\b" "\\bbegin\\b"))

                                              ;(t (error "Cursor is not on ASSERT nor RETRACT"))
         (t t)
         ))

      (global-set-key "\M-[" 'find-matching-keyword)
    #+END_SRC
*** hooks
    #+BEGIN_SRC emacs-lisp
      (add-hook 'c++-mode-hook
                (lambda ()
                  (my-indent-mode))
                )

      (add-hook 'c-mode-hook
                (lambda ()
                  ;;(setq indent-line-function (quote insert-tab))
                  (my-indent-mode)
                  ))
    #+END_SRC
** Org Mode
*** Load plugins
   #+BEGIN_SRC emacs-lisp
     (require 'org)
     (require 'org-crypt) ;;for encryption of parts of org
   #+END_SRC
*** Fonts
   #+BEGIN_SRC emacs-lisp
     (setq my-default-family "InconsolataDov")
     (setq my-default-font "InconsolataDov 11")

     ;; Make all font-lock faces fonts use inconsolata
     (dolist (face '(font-lock-builtin-face
                     font-lock-comment-delimiter-face
                     font-lock-comment-face
                     font-lock-constant-face
                     font-lock-doc-face
                     font-lock-function-name-face
                     font-lock-keyword-face
                     font-lock-negation-char-face
                     font-lock-preprocessor-face
                     font-lock-regexp-grouping-backslash
                     font-lock-regexp-grouping-construct
                     font-lock-string-face
                     font-lock-type-face
                     font-lock-variable-name-face
                     font-lock-warning-face))
       (set-face-attribute face nil :family my-default-family))

       (variable-pitch-mode t) ;something related to face (font)
       (set-face-attribute 'org-table nil :family my-default-family)
       (set-face-attribute 'org-checkbox nil :family my-default-family)
       (set-face-attribute 'org-block nil :family my-default-family)
       (set-face-attribute 'org-verbatim nil :family my-default-family :foreground "green4")
   #+END_SRC
*** Bullets
   #+BEGIN_SRC emacs-lisp
     (load "org-bullets.el")

     ;; This is a bug work around
     (defun org-element-cache-reset (&optional all) (interactive))

     (defun my-org-hook ()

       (local-set-key [(control c) (control ?.)] 'org-time-stamp)
       (local-set-key (kbd "M-S-i") 'org-toggle-inline-images) ;org-toggle-iimage-in-org)
       (local-set-key (kbd "C-c C-p p") 'org-toggle-pretty-entities)
       (local-set-key (kbd "C-<tab>") 'next-buffer) ; C-Tab: Next Buffer

       (setq org-export-with-sub-superscripts "{}") ;use only {} for sub and super script

       (org-bullets-mode)
       (setq org-bullets-bullet-list
             '("▸"
               "•"
               "•"
               "•"
               "•"
               "•"
               "•"
               ;; ♥ ● ◇ ✚ ✜ ☯ ◆ ♠ ♣ ♦ ☢ ❀ ◆ ◖ ▶
               ;;; Small
               ;; ► • ★ ▸
               ))

       (setq org-hide-emphasis-markers nil)
       (setq org-confirm-babel-evaluate nil)

       (setq bidi-paragraph-direction nil)

       (setq org-export-html-postamble nil)
       (setq org-export-html-validation-link "")

       ;; Use journal theme if requested
       ;; not sure what this is, inherited from Dov
       (setq org-entities-user '(
                                 ("models" "\\models" t "&8872;" "[models]" "models" "⊨")
                                 ("indf" "{\bf 1}" t "&#120128;" "[indf]" "indf" "𝟙")
                                 ("ell" "\\ell" t "&#2113;" "[ell]" "indf" "ℓ")
                                 ))
       )
     (add-hook 'org-mode-hook 'my-org-hook)

     ;;disable yas-mode in org-mode
     (add-hook 'org-mode-hook (lambda () (yas-minor-mode -1)))
   #+END_SRC
*** ox-slidy
    NB: for some reason this has to go *after* the previous org hooks...
   #+BEGIN_SRC emacs-lisp
     ;;Something NOT WORKING HERE
     ;;export to html-slidy
     ;;(require 'ox-slidy)
   #+END_SRC
*** ox-latex
    #+BEGIN_SRC emacs-lisp
      ;;Something NOT WORKING HERE
      ;;(require 'ox-latex)
      ;;(setq org-latex-create-formula-image-program 'dvipng)
    #+END_SRC
*** plantuml
    #+BEGIN_SRC emacs-lisp
      (setq plantuml-jar-path (concat emacs-git "Plugins/plantuml-mode/bin/"))
    #+END_SRC

*** languages
    #+BEGIN_SRC emacs-lisp
      ;; Source Languages
      (org-babel-do-load-languages
       'org-babel-load-languages
       '((sh . t)
         (perl . t)
         (emacs-lisp . t)
         (python . t)
         (ditaa . t)
         (dot . t)
         (asymptote . t)
         (plantuml . t)
         (octave . t)
         (C . t)
         (latex . t)
         ))

      (setq org-src-lang-modes
            '(("elisp" . emacs-lisp)
              ("ditaa" . artist)
              ("asymptote" . asy)
              ("dot" . fundamental)
              ("perl" . cperl)
              ("python" . python)
              ("plantuml" . plantuml)
              ))
    #+END_SRC
*** src blocks settings
    #+BEGIN_SRC emacs-lisp
      (setq org-src-tab-acts-natively t)
      (setq org-src-fontify-natively t)
    #+END_SRC
*** Apps to open links
    #+BEGIN_SRC emacs-lisp
      ;;Define programs to open files
      (if (string-match "mingw-nt" system-configuration)
          (progn
            (setq org-file-apps
                  (append
                  '(("png" . "\"c:/Program Files (x86)/giv/bin/giv.exe\" %s"))
                  '(("doc" . "\"c:/Program Files (x86)/Microsoft Office/root/Office16/WINWORD.EXE\" %s"))

                   org-file-apps
                   ))
            )
        (progn
          (setq org-file-apps
                (append
                 '(("application/png" . "eog %s"))
                 '(("application/pdf" . "evince %s"))
                 '(("application/svg" . "inkscape %s"))
                 '(("application/net" . "/usr/local/samiam/runsamiam %s"))
                 '(("application/xcf" . "gimp %s"))
                 '(("application/giv" . "giv %s"))
                 '(("application/doc" . "libreoffice -norestore %s"))
                 '(("application/odt" . "libreoffice -norestore %s"))
                 '(("\\.x?html\\'" . default))
                 org-file-apps))))
    #+END_SRC
*** Add checkbox
    #+BEGIN_SRC emacs-lisp
      (defun org-set-line-checkbox (arg)
        (interactive "P")
        (let ((n (or arg 1)))
          (when (region-active-p)
            (setq n (count-lines (region-beginning)
                                 (region-end)))
            (goto-char (region-beginning)))
          (dotimes (i n)
            (beginning-of-line)
            (skip-chars-forward "[:blank:]")
            (insert "- [ ] ")
            (if (> n 1)
              (forward-line))
          (end-of-line))))

      (global-set-key (kbd "C-M-]") 'org-set-line-checkbox)
    #+END_SRC
*** Allow selection with shift
    #+BEGIN_SRC emacs-lisp
      (setq org-support-shift-select t)
    #+END_SRC
* Emacs Env Vars
#+BEGIN_SRC emacs-lisp
  (defun my-reload-env-vars ()
                                          ; set env vars to be reloaded here
    ;; e.g.:
    ;;  (setenv "METALJET" "$PE_HOME/XjetApps/MetalJet/Apps/Project/qt/" t)
    )

                                          ;Global Env Vars
  (setenv "QMAKE" "qmake-qt5")
  (setenv "QTDIR" "/usr")
                                          ; add env vars according to bashrc...

  `my-reload-env-vars()
#+END_SRC
* Connecting various notebooks to keys
  TL;DR:
  F8 → Personal Notebook
  F9 → Work Notebook
  C-(shifted)> → This Init File
  #+BEGIN_SRC emacs-lisp
    (defun buffer-exists (bufname) (not (eq nil (get-buffer bufname))))

                                            ;Work Notebook
    (defun open-work-notes-file ()
      "Load my work notebook"
      (interactive)
      (if (buffer-exists work-notebook-filename)
          (progn
            (message "Switching to Work Notebook")
            (switch-to-buffer work-notebook-filename)
            )
        (progn
          (message "Opening Work Notebook")
          (find-file default-work-notes-file)
          (font-lock-fontify-buffer)
          (end-of-buffer)
          )
        )
      )

    (global-set-key [f9] 'open-work-notes-file)

                                            ;Personal Notebook
    (defun open-personal-notes-file ()
      "Load my personal notebook"
      (interactive)

      (if (buffer-exists personal-notebook-filename)
          (progn
            (message "Switching to Personal Notebook")
            (switch-to-buffer personal-notebook-filename)
            )
        (progn
          (message "Opening Personal Notebook")
          (find-file default-personal-notes-file)
          (font-lock-fontify-buffer)
          (end-of-buffer)
          )
        )
      )

    (global-set-key [f8] 'open-personal-notes-file)

                                            ;Init File
    (defun open-init-file ()
      "Load my personal init file"
      (interactive)
      (if (buffer-exists default-init-filename)
          (progn
            (message "Switching to Default Init File")
            (switch-to-buffer default-init-filename)
            )
        (progn
          (message "Opening Default Init File")
          (find-file default-init-file)
          )
        )
      )

    (global-set-key (kbd "C->") '(lambda () (interactive)
                                   (open-init-file)
                                   )
                    )
  #+END_SRC
* Command Histories
** Command history completion
   #+BEGIN_SRC emacs-lisp
     (define-key minibuffer-local-map
       (kbd "M-p") 'previous-complete-history-element)
     (define-key minibuffer-local-map
       (kbd "M-n") 'next-complete-history-element)
     (define-key minibuffer-local-map
       (kbd "<up>") 'previous-complete-history-element)
     (define-key minibuffer-local-map
       (kbd "<down>") 'next-complete-history-element)
   #+END_SRC
** Save history between emacs sessions
   #+BEGIN_SRC emacs-lisp
     (savehist-mode t)
   #+END_SRC
** Comint command history
   Comint is the underlying mode for interpreters, e.g. shell ipython etc.
*** Comint commands browsing
    #+BEGIN_SRC emacs-lisp
      (add-hook 'comint-mode-hook
                (lambda()
                                              ;Browsing commands from history
                  (define-key comint-mode-map [(meta p)] 'comint-previous-matching-input-from-input)
                  (define-key comint-mode-map [(kbd "<up>")] 'comint-previous-matching-input-from-input)

                  (define-key comint-mode-map [(meta n)] 'comint-next-matching-input-from-input)
                  (define-key comint-mode-map [(kbd "<down>")] 'comint-next-matching-input-from-input)

                  (define-key comint-mode-map [(control c) (control o)] 'comint-kill-output-to-kill-ring)
                  (define-key comint-mode-map [(control x) (control ?\\)] 'toggle-backslash-line)
                  (define-key comint-mode-map [(tab)] 'comint-dynamic-complete)

                                              ;Save history when the shell is killed
                  (make-local-variable 'comint-input-ring-file-name)
                  (setq comint-input-ring-file-name (concat emacs-persistance-dir "/comint-history"))
                  (setq comint-input-ring-size 10000)
                  (setq comint-process-echoes 't)
                  (comint-read-input-ring)
                  (make-local-variable 'kill-buffer-hook)
                  (add-hook 'kill-buffer-hook 'comint-write-input-ring) ;this is related to Manzyuk's stuff below
                  )
                )
    #+END_SRC
*** The following comint history recording is based on [[https://oleksandrmanzyuk.wordpress.com/2011/10/23/a-persistent-command-history-in-emacs/][A blog I found by Oleksandr Manzyuk]]
    I'm not sure if it is related to the above
    #+BEGIN_SRC emacs-lisp
     (defun comint-write-history-on-exit (process event)
       (comint-write-input-ring)
       (let ((buf (process-buffer process)))
         (when (buffer-live-p buf)
           (with-current-buffer buf
             (insert (format "\nProcess %s %s" process event))))))

     (defun turn-on-comint-history ()
       (let ((process (get-buffer-process (current-buffer))))
         (when process
           (setq comint-input-ring-file-name
                 (format “~/.emacs.d/inferior-%s-history”
                          (replace-regexp-in-string “/” “%” (process-name process))
                          ))
           (comint-read-input-ring)
           (set-process-sentinel process
                                 #'comint-write-history-on-exit))))

     (add-hook 'shell-mode-hook 'turn-on-comint-history)

     (add-hook 'kill-buffer-hook 'comint-write-input-ring)

     (defun mapc-buffers (fn)
       (mapc (lambda (buffer)
               (with-current-buffer buffer
                 (funcall fn)))
             (buffer-list)))

    (defun comint-write-input-ring-all-buffers ()
      (mapc-buffers 'comint-write-input-ring))

     (add-hook 'kill-emacs-hook 'comint-write-input-ring-all-buffers)
   #+END_SRC
* Most Recent Buffers
  #+BEGIN_SRC emacs-lisp
        ;; Most Recent Buffers
        (defun find-first-buffer-match (buffers pattern)
          (dolist (f buffers)
            (when (string-match pattern (buffer-name f))
              (return f))))

        (defun find-most-recent-pattern-buffer (pattern)
          "find the most recent code buffer in the history and switch to it"
          (let ((f (find-first-buffer-match (cdr (buffer-list)) pattern)))
            (if (not (eq f nil))
                (switch-to-buffer f)
              )
            )
          )

        (defun find-most-recent-python-buffer ()
          "find the most recent python buffer in the history and switch to it"
          (interactive)
          (find-most-recent-pattern-buffer "\\.py"))

        (defun find-most-recent-c-buffer ()
          "find the most recent c/c++ buffer in the history and switch to it"
          (interactive)
          (find-most-recent-pattern-buffer "\\.\\(cpp\\|h\\|cc\\|hh|hpp\\)$"))

        (defun find-most-recent-org-buffer ()
          "find the most recent code buffer in the history and switch to it"
          (interactive)
          (find-most-recent-pattern-buffer "\\.org\$"))

        (defun find-most-recent-shell-buffer ()
          (interactive)
          (find-most-recent-pattern-buffer "\\*shell"))

        (defun find-most-recent-magit-buffer ()
          "find the most recent magit buffer in the history and switch to it"
          (interactive)
          (find-most-recent-pattern-buffer "magit"))
  #+END_SRC
* Documentation Lookup
   #+BEGIN_SRC emacs-lisp
     ;; qt docs lookup
     (require `info-look)
     (load "qtdoc")
     (setq qtdoc-html-root "http://doc.qt.io/qt-5/")
     (global-set-key [(control h) (control q)] 'qtdoc-lookup)

     ;; google-doc searches google for the various lookup commands
     (load "google-look")

     (global-set-key [(control h) (control g)] 'google-lookup)
     (global-set-key [(control h) (control p)] 'python-lookup)
     (global-set-key [(control h) (control c)] 'cpp-lookup)
   #+END_SRC

* Various Keyboard Shortcuts
** Undo-Redo
   #+BEGIN_SRC emacs-lisp
     (defalias 'redo 'undo-tree-redo)
     (global-set-key (kbd "C-z") 'undo) ; 【Ctrl+z】
     (global-set-key (kbd "C-S-z") 'redo) ; 【Ctrl+Shift+z】;  Mac style
   #+END_SRC
** Disable default exit and minimize commands
   I trip over them accidentally while undoing and redoing too much
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-x\C-c" nil)
     (global-set-key "\C-x\C-z" nil)
   #+END_SRC
** Windows style commands
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-o" 'counsel-find-file)  ; Open file (Microsoft style) in Ivy instead of Ido

     (global-set-key (kbd "C-<f4>") 'kill-this-buffer) ; Close Buffer (Microsoft style)

     ;; C-(S)-Tab: Previous/Next Buffer
     (global-set-key (kbd "C-<tab>") 'next-buffer)
     (global-set-key (kbd "C-S-<iso-lefttab>") 'previous-buffer)
     (global-set-key (kbd "C-S-<tab>") 'previous-buffer)
   #+END_SRC
** Files
   #+BEGIN_SRC emacs-lisp
     (global-set-key "\C-x\C-r" 'revert-buffer)
   #+END_SRC
** Which-key
   This shows a popup to help remember different key combinations
   #+BEGIN_SRC emacs-lisp
(require 'which-key)
(which-key-mode)
   #+END_SRC
* Programming
   #+BEGIN_SRC emacs-lisp
     (define-key global-map (kbd "RET") 'newline-and-indent) ; For programming language modes

     (global-set-key (kbd "M-g") 'goto-line) ; Goto-line

     (global-set-key (kbd "C-<f9>") 'compile) ; Compile

     ;; Previous/Next Error (and also previous/next file in dov-git-grep)
     (global-set-key "\M-`" 'next-error)
     (global-set-key "\M-~" 'previous-error)

     (global-set-key (kbd "C-x t") 'toggle-truncate-lines)
     (set-default 'truncate-lines nil)

     (setq-default tab-width 16) ;I never use tabs. but if present they should be very visible
     (setq-default indent-tabs-mode nil) ; never use tabs when auto-indenting

     ;(electric-pair-mode f) ;Automatic Parentheses completion, should I ever want it for some reason
   #+END_SRC
* gdb
  #+BEGIN_SRC emacs-lisp
    ;;gdb and gud-gdb
    (add-hook 'gud-mode-hook
              '(lambda ()
                 (local-set-key [home] ; move to beginning of line, after prompt
                                'comint-bol)
                 (local-set-key [up] ; cycle backward through command history
                                '(lambda () (interactive)
                                   (if (comint-after-pmark-p)
                                       (comint-previous-matching-input-from-input 1)
                                     (previous-line 1))))
                 (local-set-key [down] ; cycle forward through command history
                                '(lambda () (interactive)
                                   (if (comint-after-pmark-p)
                                       (comint-next-matching-input-from-input 1)
                                     (forward-line 1))))

                 ;; External Buffer Commands
                 (define-key gud-mode-map [(alt n)] 'gud-next)
                 (define-key gud-mode-map [(alt s)] 'gud-step)
                 (define-key gud-mode-map [(alt f)] 'gud-finish)

                 ;; Load history file
                 ;;;;;WHY DOESN'T THIS WORK?!;;;;;
                 ;;             (make-local-variable 'comint-input-ring-file-name)
                 ;;             (setq comint-input-ring-file-name ((concat emacs-persistance-dir "/comint-history")))
                 ;;             (setq comint-input-ring-size 10000)
                 ;;             (set History)
                 (comint-read-input-ring)
                 (make-local-variable 'kill-buffer-hook)
                 (add-hook 'kill-buffer-hook 'comint-write-input-ring)

                 ))

    ;;Is this needed? I'm using (?) gud
    ;;(defun gdb-keys (map)
    ;;  "Set key bindings for gdb debugging"
    ;;  (interactive)
    ;;  (define-key map [(alt n)] 'gdb-next)
    ;;  (define-key map [(alt s)] 'gdb-step)
    ;;  (define-key map [(alt f)] 'gdb-finish)
    ;;  (define-key map [(alt h)] 'gdb-cont-to))
  #+END_SRC
* Autoload modes
  #+BEGIN_SRC emacs-lisp
    (setq auto-mode-alist
          (append
           (list (cons "\\.cmake$" 'cmake-mode))

           (list (cons "\\.pro$" 'makefile-mode))

           (list (cons "SConstruct" 'python-mode))
           (list (cons "SConscript" 'python-mode))
           (list (cons "\\.py$" 'python-mode))
           (list (cons "\\.run$" 'python-mode))

           (list (cons "\\.md$" 'markdown-mode))

           (list (cons "\\.h$" 'c++-mode))
           (list (cons "\\.hh$" 'c++-mode))
           (list (cons "\\.H$" 'c++-mode))
           (list (cons "\\.cxx$" 'c++-mode))
           (list (cons "\\.cc$" 'c++-mode))
           (list (cons "\\.cpp$" 'c++-mode))

           (list (cons "\\.json$" 'js2-mode))

           (list (cons "\\.xml$" 'xml-mode))

           (list (cons "\\.txt$" 'text-mode))

           (list (cons "\\.org" 'org-mode))

           (list (cons "\\.init" 'lisp-mode))
           (list (cons "\\.emacs" 'lisp-mode))
           (list (cons "\\.el" 'lisp-mode))

           (list (cons "\\.nsi" 'nsis-mode))

           (list (cons "\\.bat" 'bat-mode))

           (list (cons "\\.txt" 'text-mode))

           (list (cons "\\.bb$" 'bb-mode))
           (list (cons "\\.inc$" 'bb-mode))
           (list (cons "\\.bbappend$" 'bb-mode))
           (list (cons "\\.bbclass$" 'bb-mode))
           (list (cons "\\.conf$" 'bb-mode))

           (list (cons "\\.lua$" 'lua-mode))

           (list (cons "\\.\\([Nn][Ss][Ii]\\)$" 'nsis-mode))
           (list (cons "\\.\\([Nn][Ss][Hh]\\)$" 'nsis-mode))

           (list (cons "\\.sh$" 'shell-script-mode))

           auto-mode-alist))
  #+END_SRC
* General hooks
** before-save
   #+BEGIN_SRC emacs-lisp
     ;(add-hook ’before-save-hook ’untabify)
     ;(add-hook ’before-save-hook ’whitespace-cleanup)
   #+END_SRC